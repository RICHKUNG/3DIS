#!/usr/bin/env python3
"""Utility to duplicate a My3DIS run directory and optionally update YAML configs."""
from __future__ import annotations

if __package__ is None or __package__ == '':
    import sys
    from pathlib import Path

    project_root = Path(__file__).resolve().parents[2]
    src_path = project_root / 'src'
    if str(src_path) not in sys.path:
        sys.path.insert(0, str(src_path))




import argparse
import datetime as _dt
import os
import shutil
from pathlib import Path
from typing import Optional

try:
    import yaml
except ImportError as exc:  # pragma: no cover - dependency check
    raise SystemExit("PyYAML is required: pip install pyyaml") from exc


def build_destination(source: Path, dest_root: Optional[Path], name: Optional[str]) -> Path:
    base_root = dest_root if dest_root is not None else source.parent
    if name:
        folder_name = name
    else:
        suffix = _dt.datetime.now().strftime("%Y%m%d_%H%M%S")
        folder_name = f"{source.name}_{suffix}"
    return (base_root / folder_name).resolve()


def clone_directory(source: Path, dest: Path, mode: str) -> None:
    if dest.exists():
        raise SystemExit(f"Destination {dest} already exists")
    if mode == "link":
        copy_fn = os.link
    else:
        copy_fn = shutil.copy2
    try:
        shutil.copytree(source, dest, copy_function=copy_fn)
    except OSError as exc:
        raise SystemExit(f"Failed to clone directory: {exc}") from exc


def update_config(config_path: Path, new_run_dir: Path) -> None:
    data = yaml.safe_load(config_path.read_text())
    if not isinstance(data, dict):
        raise SystemExit(f"Config {config_path} must contain a mapping")
    experiment = data.setdefault("experiment", {})
    if not isinstance(experiment, dict):
        raise SystemExit(f"Config {config_path} has invalid experiment section")
    experiment["run_dir"] = str(new_run_dir)
    config_path.write_text(yaml.safe_dump(data, sort_keys=False, allow_unicode=True))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Clone an SSAM run directory for repeated SAM2 tracking")
    parser.add_argument("source", help="Existing run directory generated by SSAM stage")
    parser.add_argument("--dest-root", help="Folder to place the clone (default: parent of source)")
    parser.add_argument("--name", help="Name for the cloned directory (default: <source>_YYYYmmdd_HHMMSS)")
    parser.add_argument("--mode", choices=["link", "copy"], default="link", help="Clone mode: hardlink or deep copy")
    parser.add_argument("--config", help="Optional YAML config to update experiment.run_dir")
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    source = Path(args.source).expanduser().resolve()
    if not source.exists():
        raise SystemExit(f"Source directory {source} does not exist")

    dest_root = Path(args.dest_root).expanduser().resolve() if args.dest_root else None
    destination = build_destination(source, dest_root, args.name)
    print(f"Cloning {source} -> {destination} (mode={args.mode})")
    clone_directory(source, destination, args.mode)
    if args.mode == "link":
        print("Note: hardlinks share storage; in-place edits touch both copies until files are rewritten.")

    if args.config:
        config_path = Path(args.config).expanduser().resolve()
        if not config_path.exists():
            raise SystemExit(f"Config file {config_path} does not exist")
        update_config(config_path, destination)
        print(f"Updated {config_path} to use experiment.run_dir={destination}")

    print("Done.")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
